fn main() = {
    primitives_and_variables();
    operators();
    control_flow_if();
    control_flow_while();
    arrays();
    control_flow_for();
    pointers_and_references();
    slices();
    functions();
    structs();
    tuples();
    imports();
    binding_patterns();
    type_aliases();
    builtin_functions();
    extern_functions();
    running_code_at_compile_time();
    starting_a_workspace();
};

fn primitives_and_variables = {
    println("primitives_and_variables");
    
    // Primitive types:

    // boolean
    // --------
    // types: 
    //      bool
    //
    // examples: true, false

    // signed and unsigned integers
    // --------
    // types: 
    //      i8, i16, i32, i64, int (machine-sized), 
    //      u8, u16, u32, u64, uint (machine-sized)
    //
    // examples: 5, 100_000, etc.

    // floats
    // --------
    // types: f16, f32, f64, float (machine-sized)
    //
    // examples: 5.0, 3.14, 90_051.22, etc.

    // strings
    // --------
    // type: str
    //
    // examples: "Hello World"

    // A variable declaration follows the syntax
    // let [pattern]: [type] = [value]
    let num: int = 5;
    let pi: float = 3.14;
    let hello: str = "Hello";

    // The variable's type can be be inferred by its value
    let num = 5;
    let pi = 3.14;
    let hello = "Hello";

    // Variables are immutable by default, meaning you can't reassign them twice.
    // Uncomment the next line to get a compiler error:
    // num = 42;

    // To declare a variable as mutable, add the `mut` keyword after the `let`
    let mut foo = 42;
    foo = 1;

    // Variables can also be shadowed, meaning you can declare the same name twice (in local scope)
    let foo = true;
};

fn operators() = {
    println("operators");
    
    // Not
    let x = !true;

    // Negate
    let x = -5;

    // Addition
    let mut x = 1 + 2;
    x += 3;

    // Subtraction
    let mut x = 1 - 2;
    x -= 3;

    // Multiplication
    let mut x = 1 * 2;
    x *= 3;
    
    // Division
    let mut x = 1 / 2;
    x /= 3;
    
    // And
    let mut x = true && false;
    x &&= false;
    
    // Or
    let mut x = true || false;
    x ||= false;
    
    // Equal
    let x = 1 == 2;

    // Not equal
    let x = 1 != 2;

    // Less than
    let x = 1 < 2;

    // Less than or equal
    let x = 1 <= 2;

    // Greater than
    let x = 1 > 2;

    // Greater than or equal
    let x = 1 >= 2;
        
    // Bitwise not
    let x = !1;

    // Bitwise and
    let mut x = 1 & 2;
    x &= 3;
    
    // Bitwise or
    let mut x = 1 | 2;
    x |= 3;

    // Bitwise xor
    let mut x = 1 ^ 2;
    x ^= 3;

    // Shift left
    let mut x = 1 << 2;
    x <<= 3;

    // Shift right
    let mut x = 1 >> 2;
    x >>= 3;
};

fn control_flow_if = {
    println("control_flow_if");

    // If can be used as a statement
    let is_nice = true;

    if is_nice {
        println("Nice!");
    } else {
        println("Oof...");
    }

    // If is an expression, which yields 
    // the last value of the block, depending on the condition
    let answer = if true { 42 } else { -1 };

    // Since everything is an expression, you can compose blocks and ifs easily
    let some_condition = true;
    let calculation = if some_condition { 
        let this = {
            let is = 1;
            let really = 2;
        };

        let complicated = true;

        let result = 42;

        // The last expression in a block is yielded from the block,
        42 // You can make the 42 not be yielded, by adding a `;` after it
    } else { 
        -1 
    };
};


fn control_flow_while = {
    println("control_flow_while");

    let mut i = 3;

    while i > 0 {
        std.c.printf("Countdown: %d\n".data, i);
        i -= 1;
    }

    println("Launch!");
};

fn arrays = {
    // An array is a sequence of data, which its size is statically known at compile-time.
    // Arrays are bounds checked, meaning you can't index them out of bounds.
    println("arrays");

    let array: [3]int = [1, 2, 3];

    // As before, we can infer the variables type
    let words = ["Hello", ",", "World"];

    // Indexing the array
    let one = array[0];
    let world = words[2];

    // Uncomment to get an error:
    // let what_are_you_doing = words[5];
};

fn control_flow_for = {
    println("control_flow_for");

    for item, index in [42, 3.14, 666.0] {
        std.c.printf("array[%d]: %f\n".data, index, item);
    }
};

fn pointers_and_references = {
    println("pointers_and_references");

    let foo = 5;

    // Take the address of `foo` immutably with `&`
    std.c.printf("foo = %d, addr = %p\n".data, foo, &foo);

    let addr = &foo;

    // Dereference using a postfix `.*`
    let bar = addr.* + 42;
    std.c.printf("bar = %d\n".data, bar);

    // `&` references are immutable.
    // You can take a mutable reference by using `&mut`
    // In order to take something mutably, is also has to be mutable.
    // Uncomment the next two lines to get a compiler error:
    // let x = 5;
    // let y = &mut x;

    let mut x = 5;
    let y = &mut x;

    y.* += 95;
    std.c.printf("x = %d, y = %d\n".data, x, y.*);
};

fn slices = {
    // println("slices");

    // Slices are useful when you want to represent an array
    // that doesn't have statically known size, safely, since they are
    // bounds checked. They are essentially a pointer to some underlying data, and a length.

    let array = [1, 2, 3, 4, 5];
    
    fn print_slice(slice: *[]int) = {
        for x in slice {
           std.c.printf("%d\n".data, x);
        };
        println("");
    };

    // TODO (ICE): This crashes...
    // print_slice(&array[0..3]);
    
    // Slicing the elements 1-3 of the array
    let slice = &array[1..3];
    print_slice(slice);
    
    // Slicing the first 3 elements of the array
    let slice = &array[..3];
    print_slice(slice);
    
    // Slicing the last 3 elements of the array
    let slice = &array[3..];
    print_slice(slice);
};

fn functions = {
    println("functions");

    // Declaring a named function
    fn answer() -> i32 = 42;
    std.c.printf("answer = %d\n".data, answer());

    // Function types can be fully inferred
    fn five() = 5;
    std.c.printf("five = %d\n".data, five());

    // If the function takes no parameters, the parentheses can be omitted
    fn pi = 3.14;
    std.c.printf("pi = %f\n".data, pi());

    // A function can also be used as an expression, which makes it anonymous.
    // Function expressions follow the same rules as function declaration regarding type inference, omitting parentheses, etc.
    let hello = fn { "Hello" };
    println(hello());

    // Functions are first-class values, and can be passed to other functions
    fn for_each(array: *[]int, f: fn(x: int) -> ()) = 
        for x in array {
            f(x)
        };
    
    let array = [1 as int, 2, 3];
    
    for_each(&array, fn(x: int) { 
        std.c.printf("x = %d\n".data, x) ;
    });

    // When a function has only one *expected* argument, is can be elided, 
    // and will implicitly be called `it`.
    for_each(&array, fn { 
        std.c.printf("it = %d\n".data, it) ;
    });

    // Trailing functions:
    // When a function expects another function as its last argument,
    // that function argument can be put after the call. This doesn't
    // have any semantic implications, it's only syntax sugar.
    for_each(&array) fn { 
        std.c.printf("it = %d\n".data, it) ;
    };
};

fn structs = {
    println("structs");

    type Point = struct { x: int, y: int };

    // Access a struct's fields by using `.field`
    fn print_point(p: Point) = std.c.printf("x=%d y=%d\n".data, p.x, p.y);

    // Named initialization
    let my_point = Point { x: 1, y: 2 };
    print_point(my_point);

    // Anonymous initialization
    let my_point = .{ x: 1, y: 2 };
    print_point(my_point);
};

fn tuples = {
    println("tuples");
    
    // Tuples are essentially anonymous structs, with positional elements
    type Point = (i32, i32);

    // Access a tuple's elements by using `.index`
    fn print_point(p: Point) = std.c.printf("x=%d y=%d\n".data, p.0, p.1);

    // Construct a tuple by listing its elements between parentheses
    let point = (5, 10);
    print_point(point);

    // An empty tuple `()` is also called also the `unit` value. Its size is 0.
    // We usually use the unit value to represent some kind of `void`.
    let unit = ();
};

fn imports = {
    println("imports");
};

fn binding_patterns = {
    println("binding_patterns");
};

fn type_aliases = {
    println("type_aliases");
};

fn builtin_functions = {
    println("builtin_functions");
};

fn extern_functions = {
    println("extern_functions");
};

fn running_code_at_compile_time = {
    println("running_code_at_compile_time");
};

fn starting_a_workspace = {
    println("starting_a_workspace");
};
