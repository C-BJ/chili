use c.{
    malloc,
    calloc,
    realloc,
    free,
    printf
}

use process.exit

pub type String = (
    data: [*mut]u8,
    cap: uint,
    len: uint,
)

pub let String_new = fn() -> String {
    String(nil, 0, 0)
}

pub let String_from_str = fn(s: str) -> String {
    let mut string = String_new();
    String_push_str(&mut string, s);
    string
}

pub let String_get = fn(string: *String) -> str {
    string.data[0..string.len]
}

let String_grow = fn(string: *mut String) {
    let new_cap = if string.cap == 0 {
        1
    } else {
        string.cap * 2
    };

    let new_data = if string.cap == 0 {
        calloc(new_cap, @size_of(u8))
    } else {
        realloc(string.data as *u8 as _, new_cap * @size_of(u8))
    };

    string.data = if new_data != nil {
        new_data as *u8 as [*mut]u8
    } else {
        # TODO: return Result here instead of just panicking...
        printf("---------- Out Of Memory ----------\n".data);
        exit(1)
    };

    string.cap = new_cap;
}

pub let String_push = fn(string: *mut String, char: u8) {
    if string.len == string.cap { String_grow(string) }

    string.data[string.len] = char;
    string.len += 1;
}

pub let String_push_str = fn(string: *mut String, s: str) {
    for s {
        String_push(string, it);
    }
}

pub let String_pop = fn(string: *mut String) -> u8 {
    if string.len == 0 {
        return ' ';
    }

    string.len -= 1;
    string.data[string.len]
}

pub let String_drop = fn(string: *String) {
    free(string.data as *u8 as _);
}