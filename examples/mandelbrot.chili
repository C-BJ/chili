use raylib.*;
use c.*;

let mut max_iterations int = 64;
let width int = 500;
let height int = 500;

let mut scale f64 = 1;
let mut offset_x f64 = 0;
let mut offset_y f64 = 0;

let main = fn() {
	InitWindow(width, height, "chili language example - mandelbrot visualizer\0".data);

	while !WindowShouldClose() {
		BeginDrawing();
		ClearBackground(black);
		handle_input();
		plot();
		DrawFPS(10, 10);
		EndDrawing();
	}

	CloseWindow();
}

let mut start_pan Vector2;

let handle_input = fn() {
	let mpos = GetMousePosition();

	if IsMouseButtonPressed(0) {
		start_pan = mpos;
	}

	if IsMouseButtonDown(0) {
		offset_x -= (mpos.x - start_pan.x) * scale;
		offset_y -= (mpos.y - start_pan.y) * scale;
		start_pan = mpos;
	}

	let mpos_before_zoom = screen2world(mpos);
	
	if IsKeyDown(KEY_Q) {
		scale *= 0.95;
	}
	if IsKeyDown(KEY_A) {
		scale *= 1.05;
	}
	if IsKeyDown(KEY_W) {
		max_iterations += 1;
	}
	if IsKeyDown(KEY_S) {
		max_iterations -= 1;
	}
	let mpos_after_zoom = screen2world(mpos);
	offset_x -= mpos_before_zoom.x - mpos_after_zoom.x;
	offset_y -= mpos_before_zoom.y - mpos_after_zoom.y;
}

let plot = fn() {
	for x in 0..width {
		for y in 0..height {
			let n = mandelbrot(x, y);
			let n = lerp(n as _, 0, max_iterations as _, 0, 255) as u8;
			let color = Color {
				r = n,
				g = n,
				b = n,
				a = n,
			};
			DrawPixel(
				x,
				y,
				if n >= max_iterations {
					black
				} else {
					color
				}
			);
		}
	}
}

let mandelbrot = fn(x int, y int) -> int {
	let mut a = lerp((x as _) + offset_x, 0, width as _, -scale, scale);
	let mut b = lerp((y as _) + offset_y, 0, height as _, -scale, scale);

	let ca = a;
	let cb = b;

	let mut n = 0;

	while n < max_iterations {
		let aa = a * a - b * b;
		let bb = 2 * a * b;
		a = aa + ca;
		b = bb + cb;
		if a * a + b * b > 16 {
			break;
		}
		n += 1;
	}

	n
}

let lerp = fn(n f64, min f64, max f64, new_min f64, new_max f64) -> f64 {
	(n - min) / (max - min) * (new_max - new_min) + new_min
}

let screen2world = fn(v Vector2) -> Vector2 {
	.{
		x = v.x / scale + offset_x,
		y = v.y / scale + offset_y,
	}
}
