use std.*;

let foreign("system:c") {
	printf = fn(input [&]u8, ..) -> i64,
	malloc = fn(size uint) -> *(),
	free = fn(memblock *())
}

let HANDLE = int

let LPVOID = *()
let LPCSTR = [&]u8

let DWORD = i32
let LPDWORD = &DWORD

let GENERIC_READ = 0x80000000;
let GENERIC_WRITE = 0x40000000;
let GENERIC_EXECUTE = 0x20000000;
let GENERIC_ALL = 0x10000000;

let FILE_FLAG_OVERLAPPED = 0x40000000;
let FILE_ATTRIBUTE_NORMAL = 0x00000080;
let FILE_SHARE_READ = 0x00000001;
let FILE_SHARE_WRITE = 0x00000002;

let CREATE_NEW        = 1;
let CREATE_ALWAYS     = 2;
let OPEN_EXISTING     = 3;
let OPEN_ALWAYS       = 4;
let TRUNCATE_EXISTING = 5;

let INVALID_HANDLE_VALUE = -1;

let foreign("kernel32") {
	CreateFileA = fn(
		lpFileName LPCSTR,
		dwDesiredAccess DWORD, 
		dwShareMode DWORD,
		lpSecurityAttributes uint,
		dwCreationDisposition DWORD, 
		dwFlagsAndAttributes DWORD,
		hTemplateFile HANDLE
	) -> HANDLE,

	GetFileSize = fn(
		hFile HANDLE,
		lpFileSizeHigh LPDWORD
	) -> HANDLE,

	ReadFile = fn(
		hFile HANDLE,
		lpBuffer LPVOID,
		nNumberOfBytesToRead DWORD,
		lpNumberOfBytesRead LPDWORD,
		lpOverlapped &(),
	) -> bool,

	CloseHandle = fn(h HANDLE) -> bool,
	GetLastError = fn() -> i16,
	ExitProcess = fn(ec int) -> never,

	MultiByteToWideChar = fn(
		CodePage uint,
		dwFlags DWORD,
		lpMultiByteStr [&]u8,
		cpMultiByte int,
		lpWideCharStr &u16,
		cchWideChar int
	) -> int,
}

let main = fn() {
	let path = "D:\\Projects\\chili-lang\\examples\\_text_file_example.txt";
	let file_contents = read_file(path);

	let mut reverse_file_contents = String_new();
	let mut i = @as(int, file_contents.len - 1);

	while i >= 0 {
		String_push(&mut reverse_file_contents, file_contents[i]);
		i -= 1;
	}

	println();
	print_str(file_contents);
	println();
	print_str(String_get(&reverse_file_contents));
	println();

	String_drop(&reverse_file_contents);
	free(@as(_, file_contents.data));
}

let read_file = fn(path str) -> str {
	let file = CreateFileA(
		path.data,
		GENERIC_READ,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0
	);

	if file == INVALID_HANDLE_VALUE {
		let err = GetLastError();
		printf("failed opening file. err = %d\n".data, err);
		ExitProcess(1);
	}

	let file_size = GetFileSize(file, 0 as uint as _);

	let buffer [&]u8 = malloc((@as(uint, file_size)) * @size_of(u8));
	let bytes_read = 0;
	
	if !ReadFile(file, @as(_, buffer), @as(_, file_size), &bytes_read, 0 as uint as _) {
		let err = GetLastError();
		printf("failed reading file. err = %d\n".data, err);
		ExitProcess(1);
	}

	# CloseHandle(file);
	let slice = buffer[..bytes_read];

	slice
}

let println = fn() { printf("\n".data); }

let print_str = fn(slice []u8) {
	for slice {
		printf("%c".data, slice[it_index]);
	}
	println();
}