let foreign("system:libucrt") {
	printf = fn(input [&]u8, ..) -> i64,
	malloc = fn(size uint) -> *(),
	free = fn(memblock *())
}

let HANDLE = int

let LPVOID = *()
let LPCSTR = [&]u8

let DWORD = i32
let LPDWORD = &DWORD

let GENERIC_READ = 0x80000000;
let GENERIC_WRITE = 0x40000000;
let GENERIC_EXECUTE = 0x20000000;
let GENERIC_ALL = 0x10000000;

let FILE_FLAG_OVERLAPPED = 0x40000000;
let FILE_ATTRIBUTE_NORMAL = 0x00000080;
let FILE_SHARE_READ = 0x00000001;
let FILE_SHARE_WRITE = 0x00000002;

let CREATE_NEW        = 1;
let CREATE_ALWAYS     = 2;
let OPEN_EXISTING     = 3;
let OPEN_ALWAYS       = 4;
let TRUNCATE_EXISTING = 5;

let INVALID_HANDLE_VALUE = -1;

let foreign("kernel32") {
	CreateFileA = fn(
		lpFileName LPCSTR,
		dwDesiredAccess DWORD,
		dwShareMode DWORD,
		lpSecurityAttributes uint,
		dwCreationDisposition DWORD, 
		dwFlagsAndAttributes DWORD,
		hTemplateFile HANDLE
	) -> HANDLE,

	GetFileSize = fn(
		hFile HANDLE,
		lpFileSizeHigh LPDWORD
	) -> HANDLE,

	ReadFile = fn(
		hFile HANDLE,
		lpBuffer LPVOID,
		nNumberOfBytesToRead DWORD,
		lpNumberOfBytesRead LPDWORD,
		lpOverlapped &(),
	) -> bool,

	CloseHandle = fn(h HANDLE) -> bool,
	GetLastError = fn() -> i16,
	ExitProcess = fn(ec int) -> never,

	MultiByteToWideChar = fn(
		CodePage uint,
		dwFlags DWORD,
		lpMultiByteStr [&]u8,
		cpMultiByte int,
		lpWideCharStr &u16,
		cchWideChar int
	) -> int,
}

let main = fn() {
	let path = "D:\\Projects\\chili-lang\\examples\\_text_file_example.txt";
	let file_contents = read_file(path);

	println();
	print_str(file_contents);
	println();

	let lines = [5]std.String {
		std.String_new(),
		std.String_new(),
		std.String_new(),
		std.String_new(),
		std.String_new(),
	};

	defer for &lines {
		std.String_drop(it);
	};

	let mut line_index = 0;

	for char in file_contents {
		if char == '\n' {
			line_index += 1;
		} else {
			std.String_push(&mut lines[line_index], char);
		}
	}

	for line, index in &lines {
		printf("%s\n".data, std.String_get(line));
	}
}

let read_file = fn(path str) -> str {
	let file = CreateFileA(
		path.data,
		GENERIC_READ,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0
	);
	
	if file == INVALID_HANDLE_VALUE {
		let err = GetLastError();
		printf("failed opening file. err = %d\n".data, err);
		ExitProcess(1);
	}

	defer CloseHandle(file);

	let file_size = GetFileSize(file, nil);

	let buffer [&]u8 = malloc(@as(uint, file_size) * @size_of(u8));
	let bytes_read = 0;
	
	if !ReadFile(file, @as(_, buffer), @as(_, file_size), &bytes_read, nil) {
		let err = GetLastError();
		printf("failed reading file. err = %d\n".data, err);
		ExitProcess(1);
	}

	let slice = buffer[..bytes_read];

	slice
}

let println = fn() { printf("\n".data); }

let print_str = fn(slice []u8) {
	for slice {
		printf("%c".data, slice[it_index]);
	}
	println();
}