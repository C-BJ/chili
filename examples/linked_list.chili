let foreign("system:libucrt") {
    printf = fn(input [&]u8, ..) -> i64,
    malloc = fn(size uint) -> *(),
    free = fn(memblock *()),
}

pub let main = fn() {
    let mut head = new_node(0);

    push(head, +5);
    push(head, 9);
    unshift(&mut head, 30);
    push(head, 122);
    unshift(&mut head, 500);

    iterate(head, fn(value int) {
        printf("%d\n".data, value);
    });

    let first_value = shift(&mut head);
    let last_value = pop(head);

    printf(
        "first_value=%d\n".data,
        first_value
    );
    printf(
        "last_value=%d\n".data,
        last_value
    );
}

let Node = struct {
    value int,
    next &mut Self
}

let new_node = fn(value int) -> &mut Node {
    let alloc &mut Node = malloc(@size_of(Node));

    alloc.* = .{
        value = value,
        next = nil
    };

    alloc
}

let iterate = fn(head &Node, f fn(value int)) {
    let mut current = head;

    for current != nil {
        f(current.value);
        current = current.next;
    }
}

let push = fn(head &mut Node, value int) {
    let mut current = head;

    for current.next != nil {
        current = current.next;
    }

    current.next = new_node(value);
}

let unshift = fn(head &mut &mut Node, value int) {
    let new_node = new_node(value);
    new_node.next = head.*;
    head.* = new_node;
}

let shift = fn(head &mut &Node) -> int {
    if head.* == nil {
        return -1;
    }
    
    let next_node = head.*.next;
    let return_value = head.*.value;

    free(@as(_, head.*));
    
    head.* = next_node;
    
    return_value
}

let pop = fn(head &mut Node) -> int {
    if head.next == nil {
        let return_value = head.value;
        free(@as(_, head));
        return return_value;
    }

    let mut current = head;

    for current.next.next != nil {
        current = current.next;
    }
    
    let return_value = current.next.value;
    free(@as(_, current.next));
    current.next = nil;

    return_value
}